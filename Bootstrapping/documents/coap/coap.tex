\documentclass[11pt]{beamer}
\usetheme{Antibes}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{multirow}
\author{Moosa Yahyazadeh}
\title{The Constrained Application Protocol (CoAP)}
%\setbeamercovered{transparent} 
%\setbeamertemplate{navigation symbols}{} 
%\logo{} 
\institute{The University of Iowa} 
%\date{} 
\subject{rfc7252} 
\begin{document}

\begin{frame}
\titlepage
\end{frame}
%------------------------------------------------------------------------------
%\begin{frame}
%\tableofcontents
%\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{What is CoAP?}
\begin{itemize}
\item[•] The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks
\item[•] The protocol is designed for machine-to-machine (M2M) applications
\begin{itemize}
\item[•] smart energy
\item[•] building automation
\end{itemize}
\item[•] It provides a request/response interaction model between application endpoints
\begin{itemize}
\item[•] One design goal $\rightarrow$ keep message overhead small
\begin{itemize}
\item[•] Why? limiting the need for fragmentation in constrained environments
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Request/response interaction model}
\begin{itemize}
\item[•] Interaction model of CoAP is similar to the client/server model of HTTP
\item[•] Machine-to-Machine interaction result in CoAP implementation acting in both client and server roles
\item[•] CoAP request/response
\begin{itemize}
\item[•] a request is sent by a client for an action (using a Method Code) on a resource (identified by a URI) on a server
\item[•] server then sends a response with a Response Code; this response may include a resource representation
\end{itemize}
\item[•] Unlike HTTP, CoAP deals with these interchanges asynchronously over a datagram-oriented transport such as UDP.
\begin{itemize}
\item[•] using messages layer that supports optional reliability
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{CoAP layers}
\begin{itemize}
\item[•] Abstract Layering of CoAP
\end{itemize}
\begin{center}
  \begin{tabular}{ | c | c }
    \cline{1-0}
    Application &  \\ \cline{1-0} \hline
    Requests/Responses & \multirow{2}{*}{CoAP}  \\ \cline{1-0} 
    Messages &  \\ \cline{1-0} \hline
    UDP &  \\
    \cline{1-0}
  \end{tabular}
\end{center}
\begin{itemize}
\item[•] One could think of CoAP logically as using a two-layer approach, a CoAP messaging layer used to deal with UDP and the asynchronous nature of the interactions, and the request/response interactions using Method and Response Codes
\item[•] CoAP is however a single protocol, with messaging and request/response as just features
   of the CoAP header.
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Messaging model}
\begin{itemize}
\item[•] Message types
\begin{itemize}
\item[•] Confirmable
\item[•] Non-confirmable
\item[•] Acknowledgement
\item[•] Reset
\end{itemize}
\item[•] Method Codes and Response Codes included in some of these messages make them carry requests or responses
\item[•] The basic exchanges of the four types of messages are somewhat orthogonal to the request/response interactions; requests can be carried in Confirmable and Non-confirmable messages, and responses can be carried in these as well as piggybacked in Acknowledgement messages
\begin{itemize}
\item[•] Thus, Requests cannot be carried in Ack messages
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Messaging model (Cont...)}
\begin{itemize}
\item[•] Each message contains a Message ID 
\item[•] Reliability is provided by marking a message as Confirmable (CON)
\begin{itemize}
\item[•] A Confirmable message is retransmitted using a default timeout and exponential back-off between retransmissions, until the recipient sends an Acknowledgement message (ACK) with the same Message ID from the corresponding endpoint
\item[•] When a recipient is not at all able to process a Confirmable message (i.e., not even able to provide a suitable error response), it \textbf{replies} with a Reset message (RST) instead of an Acknowledgement (ACK).
\end{itemize}
\item[•] Non-confirmable messages are not acknowledged, but still have a Message ID for duplicate detection
\begin{itemize}
\item[•] When a recipient is not able to process a Non-confirmable message, it \textbf{may reply} with a Reset message (RST)
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Request/response model}
\begin{itemize}
\item[•] Request and response semantics are carried in CoAP messages
\begin{itemize}
\item[•] Request $\rightarrow$ include Method Code
\item[•] Response $\rightarrow$ include Response Code
\item[•] Optional (or default) request and response information, such as the URI and payload media type are carried as CoAP Options
\item[•] matching responses to requests independently from the underlying messages is done by Token
\begin{itemize}
\item[•] Notice: Token is a concept separate from the Message ID
\end{itemize}
\end{itemize}
\item[•] A request is carried in a Confirmable (CON) or Non-confirmable (NON) message
\begin{itemize}
\item[•] If immediately available, the response to a request carried in a Confirmable message is carried in the resulting (ACK) message
\begin{itemize}
\item[•] Called a piggybacked response
\item[•] No need for separately acknowledging a piggybacked response, as the client will retransmit the request if the (ACK) message carrying the piggybacked response is lost
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Message format}
\begin{itemize}
\item[•] CoAP is based on the exchange of compact messages
\begin{itemize}
\item[•] transported over UDP $\rightarrow$ each CoAP message occupies the data section of one UDP datagram
\item[•] may also be used over Datagram Transport Layer Security (DTLS)
\item[•] It could also be used over other transports such as SMS, TCP, or SCTP
\item[•] UDP-lite [RFC3828] and UDP zero checksum [RFC6936] are not supported by CoAP
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Message format (Cont...)}
\begin{itemize}
\item[•] messages are encoded in a simple binary format
\item[•] message structure
\begin{itemize}
\item[•] header
\item[•] token (if any)
\item[•] options (if any)
\item[•] payload marker (if there is any payload)
\item[•] payload (if any)
\end{itemize}
\end{itemize}
\begin{center}
  \begin{tabular}{*{32}{c}}
    \hline
    \multicolumn{2}{|c|}{{\scriptsize Ver}} & \multicolumn{2}{|c|}{\scriptsize T} & \multicolumn{4}{|c|}{\scriptsize TKL} & \multicolumn{8}{|c|}{\scriptsize Code} & \multicolumn{16}{|c|}{\scriptsize Message ID} \\ \hline
    \multicolumn{32}{|l}{\scriptsize Token (if any, TKL bytes) ...} \\ \hline
    \multicolumn{32}{|l}{\scriptsize Options (if any) ...} \\ \hline
    \multicolumn{8}{|c|}{\scriptsize 11111111} & \multicolumn{24}{|l}{\scriptsize Payload (if any) ...} \\ \hline 
  \end{tabular}
\end{center}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Message format - Header}
\begin{itemize}
\item[•] header (fixed-size 4-byte)
\begin{itemize}
\item[•] Version (Ver):  2-bit unsigned integer
\begin{itemize}
\item[•] CoAP version number
\item[•] Implementations of this specification MUST set this field to 1 (01 binary).  Other values are reserved for future versions. Messages with unknown version numbers MUST be silently ignored
\end{itemize}
\item[•] Type (T):  2-bit unsigned integer
\begin{itemize}
\item[•] Indicates if this message is of type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or Reset (3)
\end{itemize}
\item[•] Token Length (TKL):  4-bit unsigned integer
\begin{itemize}
\item[•] Indicates the length of the variable-length Token field (0-8 bytes)
\item[•] Lengths 9-15 are reserved, MUST NOT be sent, and MUST be processed as a message format error
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Message format - Header (Cont...)}
\begin{itemize}
\item[•] header (fixed-size 4-byte) (Cont...)
\begin{itemize}
\item[•] Code:  8-bit unsigned integer
\begin{itemize}
\item[•] split into a 3-bit class (most significant bits) and a 5-bit detail (least significant bits)
\item[•] documented as "c.dd". "c" is a digit from 0 to 7 for the 3-bit subfield and "dd" are two digits from 00 to 31 for the 5-bit subfield. 
\item[•] The class can indicate a request (0), a success response (2), a client error response (4), or a server error response (5).  (All other class values are reserved.)
\item[•] As a special case, Code 0.00 indicates an Empty message.
\item[•] In case of a request, the Code field indicates the Request Method; in case of a response, a Response Code.
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Message format - Header (Cont...)}
\begin{itemize}
\item[•] header (fixed-size 4-byte) (Cont...)
\begin{itemize}
\item[•] Message ID:  16-bit unsigned integer
\begin{itemize}
\item[•] Used to detect message duplication
\item[•] Used to to match messages of type Acknowledgement/Reset to messages of type Confirmable/Non-confirmable.
\item[•] These rules will be described later
\item[•] Its 16-bit size enables up to about 250 messages per second from one endpoint to another with default protocol parameters
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Message format - Token}

\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Rules for generating a Message ID and matching messages}

\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Code registries}

\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Request/Response Semantics}

\end{frame}
%------------------------------------------------------------------------------
\begin{frame}{Multicast CoAP}
Section 8 discusses the proper use of CoAP messages with multicast addresses and precautions for avoiding response congestion
\end{frame}
%------------------------------------------------------------------------------
\end{document}